#!/bin/bash

# Description: Helper snippets to get Fedora up and running.

# Exit on error
set -e

# Declare constants
APPLICATIONS="${HOME}/Applications"
CACHE="/cache/jonathan"
DEBUG=1
DOCUMENTS="${HOME}/Documents"
GIT="${HOME}/git"
SCRIPT_FOLDER="$(dirname "$0")"
SYSTEM_BIN="/usr/local/bin"
SYSTEM_UNITS="/etc/systemd/system"
WIN_USER="Jonathan"

RESOURCES="${SCRIPT_FOLDER}/resources"
WIN_HOME="/mnt/c/Users/${WIN_USER}"

# tmp overrides
APPLICATIONS="${HOME}/applications"
DOCUMENTS="${HOME}/documents"

mkdir -p "$APPLICATIONS"
mkdir -p "$GIT"

# Declare switches (to control program flow)

# Valid switches:

#   FEDORA
#   FEDORA_WSL
#   STEAMOS

OS="FEDORA_WSL"

if [ "$OS" = "FEDORA" ]; then

    mkdir -p "${CACHE}/Applications"
    mkdir -p "${CACHE}/git"

    if [ ! -d "$APPLICATIONS" ]; then

        ln -s "${CACHE}/Applications" "${HOME}/Applications"

    fi

    if [ ! -d "$GIT" ]; then

        ln -s "${CACHE}/git" "${HOME}/git"

    fi

fi

# Initialize flags with default values
FLAG_steamos_btrfs_installed=0
FLAG_password_set=0
FLAG_restart_required=0
FLAG_did_tweak_cpu=0
FLAG_did_tweak_mglru=0
FLAG_did_tweak_watchdog=0
FLAG_did_tweak_memory=0
FLAG_did_tweak_io_scheduler=0
FLAG_did_tweak_dragon=0
FLAG_steamapps_subvol_exists=0
FLAG_git_configured=0
FLAG_shared_config_nix_exists=0
FLAG_package_management_helper_scripts_exists=0
FLAG_btrfs_snp_installed=0
FLAG_kvm_configured=0
FLAG_images_subvol_exists=0
FLAG_emudeck_installed=0
FLAG_home_btrfs_configured=0
FLAG_ssh_configured=0
FLAG_rpmfusion_configured=0
FLAG_wsl_configured=0
FLAG_lightdm_configured=0

rpmfusion-configure() {

    func="placeholder"
    
    [ $DEBUG -eq 1 ] && echo $func

    if [ $OS = FEDORA ] && [ $FLAG_rpmfusion_configured -eq 0 ]; then

        # To enable access to both the free and the nonfree repository use the following command:

        sudo dnf install -y https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm

        # On Fedora, we default to use the openh264 library, so you need the repository to be explicitely enabled:

        sudo dnf config-manager --enable fedora-cisco-openh264

        # RPM Fusion repositories also provide Appstream metadata to enable users to install packages using Gnome Software/KDE Discover. Please note that these are a subset of all packages since the metadata are only generated for GUI packages. The following command will install the required group of packages:

        sudo dnf update -y @core

        # Fedora ffmpeg-free works most of the time, but one will experience version missmatch from time to time. Switch to the rpmfusion provided ffmpeg build that is better supported:

        sudo dnf swap ffmpeg-free ffmpeg --allowerasing

        # The following command will install the complements multimedia packages needed by gstreamer enabled applications:

        sudo dnf update -y @multimedia --setopt="install_weak_deps=False" --exclude=PackageKit-gstreamer-plugin

        # The following command will install the sound-and-video complement packages needed by some applications:

        sudo dnf install -y @sound-and-video
        sudo dnf update  -y @sound-and-video

        # Using the rpmfusion-nonfree section:

        sudo dnf install -y intel-media-driver

        # You need to have the libdvdcss package, to install libdvdcss you need enable tainted repos:

        sudo dnf install -y rpmfusion-free-release-tainted
        sudo dnf install -y libdvdcss

        # Tainted nonfree is dedicated to non-FLOSS packages without a clear redistribution status by the copyright holder. But is allowed as part of hardware inter-operability between operating systems in some countries:

        sudo dnf install -y rpmfusion-nonfree-release-tainted
        sudo dnf --repo=rpmfusion-nonfree-tainted install -y "*-firmware"

        FLAG_restart_required=1

    fi

}

rpmfusion-check() {

    func="placeholder"
    
    [ $DEBUG -eq 1 ] && echo $func

    if [ $OS = FEDORA ]; then

        repo_list=$(sudo dnf repolist)

        if echo "$repo_list" | grep -q "rpmfusion"; then

            FLAG_rpmfusion_configured=1

        fi

    fi

}

ssh-configure() {

    # todo this whole thing is finnicky, re-tool this function

    func="ssh-configure"
    
    [ $DEBUG -eq 1 ] && echo $func

    if [ $FLAG_ssh_configured -eq 0 ] && [ $OS != FEDORA_WSL ]; then

        mkdir -p "${DOCUMENTS}/SSH"

        ln -s "${DOCUMENTS}/SSH"  "${HOME}/.ssh"

    elif [ $FLAG_ssh_configured -eq 0 ] && [ $OS = FEDORA_WSL ]; then

        mkdir -p "${WIN_HOME}/Desktop/SSH"

        ln -s "${WIN_HOME}/Desktop/SSH" "${HOME}/.ssh"

        fix-ssh-permissions

    fi

}

fix-ssh-permissions() {

    # todo wsl-based distro needs to be told to use linux-style permissions on windows files from wsl.conf i think

sudo bash -c 'cat >> /etc/wsl.conf <<EOF
[automount]
options = "metadata"
EOF'

    chmod -R 600 "${WIN_HOME}/Desktop/SSH"

    FLAG_restart_required=1

}

ssh-check() {

    func="placeholder"
    
    [ $DEBUG -eq 1 ] && echo $func

    dir="${HOME}/.ssh"

    if [ -d "$dir" ]; then

        FLAG_ssh_configured=1

    fi

}

check-emudeck() {

    func="placeholder"
    
    [ $DEBUG -eq 1 ] && echo $func

    emudeck="EmuDeck.desktop"

    if [ -f "${APPLICATIONS}/EmuDeck/${emudeck}" ]; then

        FLAG_emudeck_installed=1

    fi

}

images-subvol-check() {

    func="placeholder"
    
    [ $DEBUG -eq 1 ] && echo $func

    # read: it's useful to have a single subvol for images so you can set +C and just have new child subvols inherit that property

    images_subvol="${HOME}/@images"

    if [ -d "$images_subvol" ]; then

        FLAG_images_subvol_exists=1

    fi

}

package-management-helper-scripts-install() {

    func="placeholder"
    
    [ $DEBUG -eq 1 ] && echo $func

    if [ $FLAG_package_management_helper_scripts_exists -eq 0 ]; then

        repo_name="package-management-helper-scripts"

        cd "$GIT" && git clone "https://www.github.com/celluloid-demon/${repo_name}"

    fi

}

package-management-helper-scripts-check() {

    func="placeholder"
    
    [ $DEBUG -eq 1 ] && echo $func

    repo_name="package-management-helper-scripts"

    if [ -d "${GIT}/${repo_name}" ]; then

        FLAG_package_management_helper_scripts_exists=1

    fi

}

shared-config-nix-install() {

    func="placeholder"
    
    [ $DEBUG -eq 1 ] && echo $func

    if [ $FLAG_shared_config_nix_exists -eq 0 ]; then

        url="https://www.github.com/celluloid-demon/shared-config-nix"

        cd "$APPLICATIONS" && git clone "$url"

        cd "${HOME}"
        ln -s "${APPLICATIONS}/shared-config-nix/home/bin" bin
        ln -s "${APPLICATIONS}/shared-config-nix/home/usr" usr
        ln -s "${APPLICATIONS}/shared-config-nix/dot-files/bash_aliases" .bash_aliases

# source .bash_aliases through .bashrc
cat << EOF | tee -a "${HOME}/.bashrc"

if [ -f "\${HOME}/.bash_aliases" ]; then

    . "\${HOME}/.bash_aliases"

fi

EOF

    fi

}

shared-config-nix-check() {

    func="placeholder"
    
    [ $DEBUG -eq 1 ] && echo $func

    dir="${APPLICATIONS}/shared-config-nix"

    if [ -d "$dir" ]; then

        FLAG_shared_config_nix_exists=1

    fi

}

git-config-check() {

    func="placeholder"
    
    [ $DEBUG -eq 1 ] && echo $func

    # (temporarily disable exit on error)
    set +e
    git_user_name="$(git config --global --get user.name)"
    set -e

    if [ ! -z "$git_user_name" ]; then

        FLAG_git_configured=1

    fi

}

git-configure() {

    func="placeholder"
    
    [ $DEBUG -eq 1 ] && echo $func

    if [ $FLAG_git_configured -eq 0 ]; then

        echo

        # Prompt for user's name
        read -p "Enter your git name (this can just be your first name, lower-case): " name

        # Prompt for user's email
        read -p "Enter your GitHub email (recommend GitHub ***private*** email): " email

        # Set the username in Git configuration
        git config --global user.name "$name"

        # Set the commit email address in Git configuration
        git config --global user.email "$email"

    fi

}

check-kvm-config() {

    func="placeholder"
    
    [ $DEBUG -eq 1 ] && echo $func

    config="/etc/libvirt/libvirtd.conf"
    search="#[[:space:]]*unix_sock_rw_perms = \"0770\""

    # Read: If comment "# unix_sock_rw_perms..." found, assume config was successfully edited
    if ! grep -qE "$search" "$config"; then

        FLAG_kvm_configured=1

    fi

}

configure-kvm() {

    func="placeholder"
    
    [ $DEBUG -eq 1 ] && echo $func

    config="/etc/libvirt/libvirtd.conf"

    sudo sed -i 's/#\s*unix_sock_group = "libvirt"/unix_sock_group = "libvirt"/' "$config"
    sudo sed -i 's/#\s*unix_sock_rw_perms = "0770"/unix_sock_rw_perms = "0770"/' "$config"

    sudo usermod -a -G libvirt $(whoami)

    sudo systemctl start  libvirtd.service
    sudo systemctl start  virtlogd.service
    sudo systemctl enable libvirtd.service
    sudo systemctl enable virtlogd.service

    sudo virsh net-start     default
    sudo virsh net-autostart default

    FLAG_restart_required=1

}

steamos-tweak-dragon-check() {

    func="steamos-tweak-dragon-check"
    
    [ $DEBUG -eq 1 ] && echo $func

    if [ $OS = STEAMOS ]; then

        grub_config=$(cat /etc/default/grub)

        if grep -q "mitigations=off" <<< "$grub_config"; then

            FLAG_did_tweak_dragon=1

        fi

    fi

}

steamos-tweak-io-scheduler-check() {

    func="placeholder"
    
    [ $DEBUG -eq 1 ] && echo $func

    if [ $OS = STEAMOS ]; then

        rules_file="/etc/udev/rules.d/64-ioschedulers.rules"

        if [ -f "$rules_file" ]; then

            FLAG_did_tweak_io_scheduler=1

        fi

    fi

}

steamos-tweak-memory-check() {

    func="placeholder"
    
    [ $DEBUG -eq 1 ] && echo $func

    if [ $OS = STEAMOS ]; then

        conf_file="/etc/security/limits.d/memlock.conf"

        if [ -f "$conf_file" ]; then

            FLAG_did_tweak_memory=1

        fi

    fi

}

steamos-tweak-watchdog-check() {

    func="steamos-tweak-watchdog-check"
    
    [ $DEBUG -eq 1 ] && echo $func

    if [ $OS = STEAMOS ]; then

        grub_config=$(cat /etc/default/grub)

        if grep -q "nowatchdog nmi_watchdog=0" <<< "$grub_config"; then

            FLAG_did_tweak_watchdog=1

        fi

    fi

}

steamos-tweak-mglru-check() {

    func="placeholder"
    
    [ $DEBUG -eq 1 ] && echo $func

    if [ $OS = STEAMOS ]; then

        conf_file="/etc/tmpfiles.d/mglru.conf"

        if [ -f "$conf_file" ]; then

            FLAG_did_tweak_mglru=1

        fi

    fi

}

password-check() {

    func="placeholder"
    
    [ $DEBUG -eq 1 ] && echo $func

    if [ "$OS" = "FEDORA" ]; then

        password_status=$(sudo passwd --status "$USER" | awk '{print $2}')

        if [ "$password_status" = "PS" ]; then FLAG_password_set=1; fi

    elif [ "$OS" = "FEDORA_WSL" ]; then

        password_status=$(passwd --status "$USER" | awk '{print $2}')

        if [ "$password_status" = "P" ]; then FLAG_password_set=1; fi

    elif [ "$OS" = "STEAMOS" ]; then

        password_status=$(passwd --status | awk '{print $2}')

        if [ "$password_status" = "P" ]; then FLAG_password_set=1; fi

    fi

}

steamos-tweak-cpu-check() {

    func="placeholder"
    
    [ $DEBUG -eq 1 ] && echo $func

    if [ $OS = STEAMOS ]; then

        service_file="/etc/systemd/system/cpu_performance.service"

        if [ -f "$service_file" ]; then

            FLAG_did_tweak_cpu=1

        fi

    fi

}

steamos-tweak-cpu-install() {

    func="placeholder"
    
    [ $DEBUG -eq 1 ] && echo $func

    # Unfortunately, even the newest (at the time of writing) SteamOS 3.5 release still ships with a CPU governor called schedutil, which is less than desirable if you want a rather even & consistent frame-pacing, because of the erratic downclocking behavior it has become famous for in Linux enthusiast circles.

    # On the other hand, the performance governor does exactly what it says on the tin:

    # "It always requests the highest performance state of the CPU that is available, thus either preventing or at the very least reducing many of the dreaded frame-time spikes plaguing the schedutil governor."

    # But what about my temperatures — is it going to melt my Steam Deck ???

    # The short answer is: No, it won’t!

    # The slighty longer answer:

    # All modern CPUs (including the Steam Deck’s AMD Zen 2 architecture) have so-called “sleep states”, which allow the CPU to almost completely power-off certain parts of individual cores at any given opportunity, which ensures they save the most amount of energy & heat, way more so than what the simplistic downclocking strategy could ever hope to achieve.

    # source: https://medium.com/@a.b.t./here-are-some-possibly-useful-tweaks-for-steamos-on-the-steam-deck-fcb6b571b577

    if [ $OS = STEAMOS ] && [ $FLAG_did_tweak_cpu -eq 0 ]; then

cat << EOF | sudo tee /etc/systemd/system/cpu_performance.service
[Unit]
Description=CPU performance governor
[Service]
Type=oneshot
ExecStart=/usr/bin/cpupower frequency-set -g performance
[Install]
WantedBy=multi-user.target
EOF

        sudo systemctl daemon-reload
        sudo systemctl enable cpu_performance.service

        FLAG_restart_required=1

    fi

}

steamos-tweak-mglru-install() {

    func="placeholder"
    
    [ $DEBUG -eq 1 ] && echo $func

    # This is one of the most recent additions to the upstream Linux kernel, literally just merged for the 6.1 LTS (Long-Term Support) version which the SteamOS 3.5 release switched towards over the 5.13 kernel used previously.

    # It is a feature developed by a Google engineer to dramatically improve upon the memory management of Linux, and is already in use on both Android & ChromeOS.

    # However, the upstream kernel doesn’t enable this functionality by default, yet.

    # source: https://medium.com/@a.b.t./here-are-some-possibly-useful-tweaks-for-steamos-on-the-steam-deck-fcb6b571b577

    if [ $OS = STEAMOS ] && [ $FLAG_did_tweak_mglru -eq 0 ]; then

cat << EOF | sudo tee /etc/tmpfiles.d/mglru.conf
w /sys/kernel/mm/lru_gen/enabled - - - - 7
w /sys/kernel/mm/lru_gen/min_ttl_ms - - - - 0
EOF

        FLAG_restart_required=1

    fi

}

steamos-tweak-watchdog-install() {

    func="placeholder"
    
    [ $DEBUG -eq 1 ] && echo $func

    # A watchdog timer in computer terminology is either a piece of hardware or software which can be used for both detection & recovery of malfunctions.

    # These are critical components for enterprise devices in order to ensure that they meet high-availability demands, however the Steam Deck is none of that.

    # Therefore, disabling the watchdog timers has no ill-effects; to the contrary, it can actually help the Steam Deck by not generating any interrupt requests of its own.

    # source: https://medium.com/@a.b.t./here-are-some-possibly-useful-tweaks-for-steamos-on-the-steam-deck-fcb6b571b577

    if [ $OS = STEAMOS ] && [ $FLAG_did_tweak_watchdog -eq 0 ]; then

        sudo sed -i 's/\bGRUB_CMDLINE_LINUX_DEFAULT="\b/&nowatchdog nmi_watchdog=0 /' /etc/default/grub

        sudo grub-mkconfig -o /boot/efi/EFI/steamos/grub.cfg

        FLAG_restart_required=1

    fi

}

steamos-tweak-memory-install() {

    func="placeholder"
    
    [ $DEBUG -eq 1 ] && echo $func

    # This is an optimization which will especially help RPCS3, which is an emulator for Sony’s PlayStation 3 console.

    # In fact, when you run RPCS3 from a terminal on Linux, it will complain with the following message:

    # "Warning message: Failed to set RLIMIT_MEMLOCK size to 2 GiB. Try to update your system configuration."

    # By default, the Linux kernel sets this particular value to just 64KiB, which is the maximum amount of memory the kernel will lock within a single operation, and the following is what one of the main developers of RPCS3 had to say on the topic:

    # "64K is some outdated over-precautious limitation from 1990’s era."

    # Well, okay then, let’s increase our limit to 2GiB in order to advance into the 2020’s era:

    # source: https://medium.com/@a.b.t./here-are-some-possibly-useful-tweaks-for-steamos-on-the-steam-deck-fcb6b571b577

    if [ $OS = STEAMOS ] && [ $FLAG_did_tweak_memory -eq 0 ]; then

cat << EOF | sudo tee /etc/security/limits.d/memlock.conf
* hard memlock 2147484
* soft memlock 2147484
EOF

        FLAG_restart_required=1

    fi

}

steamos-tweak-io-scheduler-install() {

    func="placeholder"
    
    [ $DEBUG -eq 1 ] && echo $func

    # An I/O-scheduler tries to efficiently balance both read & write performance as well as the latency of access times to block devices such as a NVMe SSD, eMMC storage or even a microSD card.

    # SteamOS has three different I/O-schedulers to choose from. [Technically, there’s also the option of having no I/O-scheduler at all.]

    # By default, it uses mq-deadline, which is a port of the older deadline scheduler from a time when the block subsystem of the Linux kernel only had a single queue to work with, towards the more efficient multi-queue design of contemporary Linux.

    # The other two remaining options are called bfq & kyber:

    # BFQ has a strict focus on providing low-latency I/O-operations even under heavy loads; however, that achievement comes at the cost of reduced throughput performance, in particular when it comes to write speeds.

    # Kyber on the other hand was developed by Facebook for use on their high-end storage servers. Therefore, it has a rather simple design that is light on the strain it puts on the CPU.

    # In practice, I found Kyber to be the best all-rounder among the three, since it allows the diverse storage devices to both reach the maximum capacity of their respective throughput (i.e. read & write) speeds while at the same time still providing low enough latencies even among high I/O pressure.

    # source: https://medium.com/@a.b.t./here-are-some-possibly-useful-tweaks-for-steamos-on-the-steam-deck-fcb6b571b577

    if [ $OS = STEAMOS ] && [ $FLAG_did_tweak_io_scheduler -eq 0 ]; then

cat << EOF | sudo tee /etc/udev/rules.d/64-ioschedulers.rules
ACTION=="add|change", KERNEL=="nvme[0-9]*", ATTR{queue/scheduler}="kyber"
ACTION=="add|change", KERNEL=="sd[a-z]|mmcblk[0-9]*", ATTR{queue/rotational}=="0", ATTR{queue/scheduler}="kyber"
EOF

        FLAG_restart_required=1

    fi

}

steamos-tweak-dragon-install() {

    func="placeholder"
    
    [ $DEBUG -eq 1 ] && echo $func

    # Disabling CPU security flaw mitigations

    # (a.k.a. Here Be Dragons!)

    # Let me start by explicitly stating that the change described in this segment has the hypothetical potential of becoming a security risk for SteamOS, so caveat emptor!

    # Having said that, I am limiting my personal risk exposure by only disabling the CPU mitigations when my Steam Deck is in offline mode.

    # This has the added benefit of preserving battery life, because an active WLAN/WiFi connection requires energy to operate, obviously.

    # And since I exclusively play offline single-player games which don’t require an active Internet connection anyway, disabling the costly CPU mitigations is viable for me personally.

    # Now, disabling the security flaw mitigations can boost the performance of SteamOS quite a bit on Steam Deck’s AMD Zen 2 CPU architecture, especially with the most recent hardware bug named Retbleed.

    # For a good demonstration of the current penalty and the potential performance uplift by deactivating the mitigations on Zen 2 CPUs, I can once again point you towards this benchmark done by Phoronix:

    # https://www.phoronix.com/review/amd-3950x-retbleed

    # Thus, if you personally are comfortable with running an operating system with a known security risk that theoretically could be exploited, then the following command will have you covered:

    # source: https://medium.com/@a.b.t./here-are-some-possibly-useful-tweaks-for-steamos-on-the-steam-deck-fcb6b571b577

    if [ $OS = STEAMOS ] && [ $FLAG_did_tweak_dragon -eq 0 ]; then

        sudo sed -i 's/\bGRUB_CMDLINE_LINUX_DEFAULT="\b/&mitigations=off /' /etc/default/grub

        sudo grub-mkconfig -o /boot/efi/EFI/steamos/grub.cfg

        FLAG_restart_required=1

    fi

}

home-btrfs-check() {

    func="home-btrfs-check"
    
    [ $DEBUG -eq 1 ] && echo $func

    set +e
    home_mount="$(cat /proc/mounts | grep /home)"

    if echo "$home_mount" | grep -q btrfs; then

        FLAG_home_btrfs_configured=1

    fi
    set -e

}

install-steamos-btrfs() {

    func="placeholder"
    
    [ $DEBUG -eq 1 ] && echo $func

    # WARNING: Recommended to do this FIRST so downstream package / flatpak installations are able to take advantage of zstd compression.

    t="$(mktemp -d)"

    curl -sSL https://gitlab.com/popsulfr/steamos-btrfs/-/archive/main/steamos-btrfs-main.tar.gz | tar -xzf - -C "$t" --strip-components=1

    "$t/install.sh"

    rm -rf "$t"

    # Let steamos-btrfs do its thing
    exit 0

}

packages-install-from-pacman() {

    func="placeholder"
    
    [ $DEBUG -eq 1 ] && echo $func

    if [ $OS = STEAMOS ]; then

        sudo steamos-readonly disable

        sudo pacman-key --init
        sudo pacman-key --populate archlinux
        sudo pacman-key --populate holo

        # WARNING: Steamdeck rootfs partition only has ~5G allocated for it, be VERY judicious with what you add here to avoid bricking your system!

        # NOTE: Arch doesn't use service scripts, so 'null' is the answer to your question. However, since you want to use vmware, it needs to put it's scripts somewhere, and /etc/init.d is as good a place as any.

        PACKAGES="byobu krfb tldr"
        PACKAGES_AUR="base-devel go"
        PACKAGES_VMWARE="dkms libaio gcr fuse2 gtkmm linux-neptune-headers ncurses libcanberra pcsclite"

        # NOTE: The vmware-workstation PKGBUILD contains instructions on how to avoid the package having a dependency on vmware-keymaps.

        # WARNING: Steam Deck repos might not ship the latest linux headers matching your kernel version, you can download the up-to-date version of your headers for vmware manually and install via `sudo pacman -U <linux_headers_archive>`

        # WARNING: To download headers manually:
        # WARNING: https://steamdeck-packages.steamos.cloud/archlinux-mirror/jupiter-main/os/x86_64/
        # WARNING: source:
        # WARNING: https://www.reddit.com/r/SteamDeck/comments/y6uudu/installing_kernel_headers/

    #     PACKAGES_KVM="dnsmasq libvirt qemu-base virt-manager"
    #     PACKAGES_KVM_TPM="swtpm"

        sudo pacman --needed --noconfirm -Syu $PACKAGES $PACKAGES_AUR $PACKAGES_VMWARE

        sudo steamos-readonly enable

    fi

}

lightdm-configure() {

    func="lightdm-configure"
    
    [ $DEBUG -eq 1 ] && echo $func

    if which lightdm >/dev/null 2>&1; then

        FLAG_lightdm_configured=1

    fi

    if [ $OS = FEDORA_WSL ] && [ $FLAG_lightdm_configured -eq 0 ]; then

        sudo systemctl disable sddm
        sudo systemctl enable  lightdm

        FLAG_restart_required=1

    fi

}

packages-install-from-dnf() {

    func="packages-install-from-dnf"
    
    [ $DEBUG -eq 1 ] && echo $func

    PACKAGES_COMMON="byobu gh git-core krfb podman pv rsync tldr tree"
    PACKAGES_WSL_ONLY="lightdm xorg-x11-server-Xephyr"

    if [ $OS = FEDORA ]; then

        PACKAGES_VSCODE="code"

        # WARNING: Fedora rootfs partition only has ~20G allocated for it, you've got wiggle room but you should still be relying on flatpaks for most apps

        # VSCode
        set +e
        if ! which code >/dev/null 2>&1; then

            sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc

            echo -e "[code]\nname=Visual Studio Code\nbaseurl=https://packages.microsoft.com/yumrepos/vscode\nenabled=1\ngpgcheck=1\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc" | sudo tee /etc/yum.repos.d/vscode.repo > /dev/null

        fi
        set -e

        sudo dnf upgrade -y
        sudo dnf install -y $PACKAGES_COMMON $PACKAGES_VSCODE

        sudo dnf groupinstall -y "Development Tools" "Development Libraries"

    fi

    if [ $OS = FEDORA_WSL ]; then

        # reference: https://docs.fedoraproject.org/en-US/quick-docs/switching-desktop-environments/

        sudo dnf upgrade -y
        sudo dnf install -y $PACKAGES_COMMON $PACKAGES_WSL_ONLY

        sudo dnf groupinstall -y "Development Tools" "Development Libraries"

        sudo dnf install -y @kde-desktop
        sudo dnf install -y @kde-desktop-environment
        sudo dnf groupinstall -y "KDE Plasma Workspaces"

    fi

}

packages-install-from-flathub() {

    func="placeholder"
    
    [ $DEBUG -eq 1 ] && echo $func

    if [ $OS = FEDORA ]; then

        flatpak remote-add --user --if-not-exists flathub https://dl.flathub.org/repo/flathub.flatpakrepo

    fi

    # WARNING: Ran into issues with these
    FLATPAKS_PROBLEM="

    com.play0ad.zeroad
    org.kde.kmymoney

    "

    FLATPAKS_COMMON="

    com.github.flxzt.rnote
    com.github.jeromerobert.pdfarranger
    com.github.tchx84.Flatseal
    com.google.Chrome
    com.toolstack.Folio
    com.valvesoftware.SteamLink
    com.visualstudio.code-oss

    de.haeckerfelix.Shortwave
    fr.handbrake.ghb
    io.github.OpenToonz
    io.mpv.Mpv
    io.podman_desktop.PodmanDesktop
    net.ankiweb.Anki
    net.davidotek.pupgui2
    net.lutris.Lutris
    net.mediaarea.MediaInfo

    org.audacityteam.Audacity
    org.blender.Blender
    org.bunkus.mkvtoolnix-gui
    org.freecadweb.FreeCAD
    org.gimp.GIMP
    org.gnome.Boxes
    org.gnome.Lollypop
    org.kde.kdenlive
    org.kde.krita
    org.kde.kstars
    org.kde.ksudoku
    org.kde.skanpage
    org.libreoffice.LibreOffice
    org.openmw.OpenMW
    org.qbittorrent.qBittorrent
    org.wesnoth.Wesnoth/x86_64/stable

    "

    FLATPAKS_STEAMOS_ONLY="

    org.mozilla.firefox
    org.kde.kcalc
    org.kde.kolourpaint
    org.kde.konversation
    org.kde.kpat
    org.kde.kwalletmanager5

    "

#   (note: discord flatpak deprecated in favor of "full" linux version from website, with screen-sharing, etc)
#   flatpak install flathub com.discordapp.Discord -y

    if [ $OS = FEDORA ]; then

        flatpak update --user -y
        flatpak install --user flathub $FLATPAKS_COMMON -y

    fi

    if [ $OS = STEAMOS ]; then

        # NOTE: steamOS installs flatpaks to user's home directory by default
        flatpak update -y
        flatpak install flathub $FLATPAKS_COMMON $FLATPAKS_STEAMOS_ONLY -y

    fi

}

btrfs-snp-install-from-repo() {

    func="placeholder"
    
    [ $DEBUG -eq 1 ] && echo $func

    if [ $OS = FEDORA ] || [ $OS = STEAMOS ]; then

        set +e
        if ! which btrfs-snp >/dev/null 2>&1; then

            set -e

            url="https://www.github.com/celluloid-demon/btrfs-snp"
            repo_name="$(basename "$url" .git)"

            cd "$APPLICATIONS"

            git clone "$url"

            cd "$repo_name"

            # unlock system
            if [ $OS = STEAMOS ]; then sudo steamos-readonly disable; fi

            ./flash

            # lock system
            if [ $OS = STEAMOS ]; then sudo steamos-readonly enable; fi

            FLAG_restart_required=1

        fi
        set -e

    fi

}

btrfs-sync-install-from-repo() {

    func="placeholder"
    
    [ $DEBUG -eq 1 ] && echo $func

    if [ $OS = FEDORA ] || [ $OS = STEAMOS ]; then

        set +e
        if ! which btrfs-sync >/dev/null 2>&1; then

            set -e

            url="https://www.github.com/celluloid-demon/btrfs-sync"
            repo_name="$(basename "$url" .git)"

            cd "$APPLICATIONS"

            git clone "$url"

            cd "$repo_name"

            # unlock system
            if [ $OS = STEAMOS ]; then sudo steamos-readonly disable; fi

            ./flash

            # lock system
            if [ $OS = STEAMOS ]; then sudo steamos-readonly enable; fi

            FLAG_restart_required=1

        fi
        set -e

    fi

}

rsync-helper-scripts-install-from-repo() {

    func="placeholder"
    
    [ $DEBUG -eq 1 ] && echo $func

    if [ $OS = FEDORA ] || [ $OS = FEDORA_WSL ]; then

        set +e
        if ! which rsync-wrapper >/dev/null 2>&1; then

            set -e

            url="https://www.github.com/celluloid-demon/rsync-helper-scripts"
            repo_name="$(basename "$url" .git)"

            cd "$APPLICATIONS"

            git clone "$url"

            cd "$repo_name"

            # unlock system
            if [ $OS = STEAMOS ]; then sudo steamos-readonly disable; fi

            # todo
            # ./flash

            # lock system
            if [ $OS = STEAMOS ]; then sudo steamos-readonly enable; fi

            FLAG_restart_required=1

        fi
        set -e

    fi

}

discord-install-from-web() {

    func="placeholder"
    
    [ $DEBUG -eq 1 ] && echo $func

    if [ $OS != FEDORA_WSL ] && [ ! -d "${APPLICATIONS}/Discord" ]; then

        url="https://discord.com/api/download?platform=linux&format=tar.gz"

        wget -O "${HOME}/Downloads/discord.tar.gz" "$url"

        tar -xvzf "${HOME}/Downloads/discord.tar.gz" -C "${APPLICATIONS}/"

        desktop_file="discord.desktop"

        mkdir -p "${HOME}/.local/share/applications"

        cp "${APPLICATIONS}/Discord/${desktop_file}" "${HOME}/.local/share/applications/"

        if [ $OS = FEDORA ]; then
        sed -i 's|^Exec=.*|Exec=/home/jonathan/Applications/Discord/Discord|g'     "${HOME}/.local/share/applications/${desktop_file}"
        sed -i 's|^Icon=.*|Icon=/home/jonathan/Applications/Discord/discord.png|g' "${HOME}/.local/share/applications/${desktop_file}"
        fi

        if [ $OS = STEAMOS ]; then
        sed -i 's|^Exec=.*|Exec=/home/deck/Applications/Discord/Discord|g'     "${HOME}/.local/share/applications/${desktop_file}"
        sed -i 's|^Icon=.*|Icon=/home/deck/Applications/Discord/discord.png|g' "${HOME}/.local/share/applications/${desktop_file}"
        fi

    fi

}

from-web-get-emudeck-installer() {

    func="placeholder"
    
    [ $DEBUG -eq 1 ] && echo $func

    # grabbing essentially another bootstrap file, we don't need to get too fancy

    url="https://www.emudeck.com/EmuDeck.desktop"

    cd "${HOME}/Desktop" && wget "$url"

}

steamapps-subvol-check() {

    func="placeholder"
    
    [ $DEBUG -eq 1 ] && echo $func

    steam_folder="/home/deck/.local/share/Steam"
    steamapps_subvol_name="@steamapps"

    if [ -d "${steam_folder}/${steamapps_subvol_name}" ]; then

        FLAG_steamapps_subvol_exists=1

    fi

}

steamapps-subvol-create() {

    func="placeholder"
    
    [ $DEBUG -eq 1 ] && echo $func

    if [ $OS = STEAMOS ] && [ $FLAG_steamapps_subvol_exists -eq 0 ]; then

        steam_folder="/home/deck/.local/share/Steam"
        steamapps_folder_name="steamapps"
        steamapps_subvol_name="@steamapps"

        # make sure steam isn't running while we're doing this
        echo
        echo "  WARNING: Please take a moment to close Steam (press enter when ready to procede)"
        read response

        # (create steamapps folder if missing to satisfy logic because I'm lazy)
        if [ ! -d "${steam_folder}/${steamapps_folder_name}" ]; then mkdir -p "${steam_folder}/${steamapps_folder_name}"; fi

        sudo btrfs subvolume create "${steam_folder}/${steamapps_subvol_name}"

        # NOTE: Trailing slashes are significant!
        sudo rsync -av "${steam_folder}/${steamapps_folder_name}/" "${steam_folder}/${steamapps_subvol_name}/"

        sudo rm -rf "${steam_folder}/${steamapps_folder_name}"

        ln -s "${steam_folder}/${steamapps_subvol_name}" "${steam_folder}/${steamapps_folder_name}"

    fi

}

images-subvol-create() {

    func="placeholder"
    
    [ $DEBUG -eq 1 ] && echo $func

    if [ $OS = STEAMOS ] && [ $FLAG_images_subvol_exists -eq 0 ]; then

        libvirt_folder="/var/lib/libvirt"
        images_folder_name="images"
        images_subvol_name="@images"

        sudo btrfs subvolume create "${HOME}/${images_subvol_name}"

        #######################################
        #                                     #
        #          !!! IMPORTANT !!!          #
        #                                     #
        #######################################
        sudo chattr +C "${HOME}/${images_subvol_name}"

        # NOTE: Trailing slashes are significant!
        sudo rsync -av "${libvirt_folder}/${images_folder_name}/" "${HOME}/${images_subvol_name}/"

        sudo rm -rf "${libvirt_folder}/${images_folder_name}"

        sudo ln -s "${HOME}/${images_subvol_name}" "${libvirt_folder}/${images_folder_name}"

    fi

}

password-set() {

    func="placeholder"
    
    [ $DEBUG -eq 1 ] && echo $func

    if [ $FLAG_password_set -eq 0 ]; then

        passwd

    fi

}

home-btrfs-configure() {

    func="placeholder"

    [ $DEBUG -eq 1 ] && echo $func

    if [ $FLAG_home_btrfs_configured -eq 1 ]; then

        echo "/home btrfs detected..."

    elif [ $OS = FEDORA ]; then

        echo "/home btrfs NOT detected (out of scope of this bootstrap, come back when it's done)"
        exit 1

    elif [ $OS = STEAMOS ]; then

        echo "/home btrfs NOT detected, do you wish to install steamos-btrfs? (y/n): "
        read response

        if [ "$response" = "y" ]; then

            # (SEE WARNING)
            install-steamos-btrfs

        elif [ "$response" = "n" ]; then

            echo "WARNING: steamos-btrfs required for optimizations, terminating..."
            exit 1

        else

            echo "Invalid response, terminating..."
            exit 1

        fi

    fi

}

end-step() {

    func="placeholder"
    
    [ $DEBUG -eq 1 ] && echo $func

    if [ $FLAG_restart_required -eq 1 ]; then

        echo
        echo "  ######################################################"
        echo "  #                                                    #"
        echo "  #     WARNING: System restart highly encouraged!     #"
        echo "  #                                                    #"
        echo "  ######################################################"
        echo

    fi

    echo
    echo "  ...completed successfully!"
    echo

}

configure-wsl() {

    func="configure-wsl"
    
    [ $DEBUG -eq 1 ] && echo $func

    config="${WIN_HOME}/.wslconfig"

    if [ -f "$config" ]; then

        FLAG_wsl_configured=1

    fi

    if [ $OS = FEDORA_WSL ] && [ $FLAG_wsl_configured -eq 0 ]; then

cat << EOF | tee "$config"
[wsl2]
vmIdleTimeout=-1
EOF

        # make a dummy systemd service (to be "manually" started by task
        # scheduler on windows login), this combined with the prior timeout setting will theoretically start wsl in the background and
        # allow it to keep running for other systemd services, mainly
        # rsync backup scripts
        executable="dummy"
        service="dummy.service"

        sudo cp "${RESOURCES}/${executable}" "${SYSTEM_BIN}/"
        sudo cp "${RESOURCES}/${service}"    "${SYSTEM_UNITS}/"

        systemd-analyze verify "${SYSTEM_UNITS}/${service}"

        # NOTE: If you'd like to start this service whenever you login to Windows, create a "Scheduled Task" in Windows which runs on Logon and points to wsl.exe with the arguments being -u root -e sh -c "systemctl status dummy || systemctl start dummy"

        FLAG_restart_required=1

    fi

}

main() {

    password-check
    password-set

    configure-wsl

    home-btrfs-check
    home-btrfs-configure

    steamos-tweak-cpu-check
    steamos-tweak-mglru-check
    steamos-tweak-watchdog-check
    steamos-tweak-memory-check
    steamos-tweak-io-scheduler-check
    steamos-tweak-dragon-check

    steamos-tweak-cpu-install
    steamos-tweak-mglru-install
    steamos-tweak-watchdog-install
    steamos-tweak-memory-install
    steamos-tweak-io-scheduler-install
    steamos-tweak-dragon-install

    steamapps-subvol-check
    steamapps-subvol-create

    ######################################
    #                                    #
    #          STAGE 1 PACKAGES          #
    #                                    #
    ######################################

    rpmfusion-check
    rpmfusion-configure

    packages-install-from-dnf
    packages-install-from-flathub
    packages-install-from-pacman    

    ##################################
    #                                #
    #          POST-STAGE 1          #
    #                                #
    ##################################

    git-config-check
    git-configure

    lightdm-configure

    ###############################################
    #                                             #
    #          STAGE 2 PACKAGES                   #
    #                                             #
    #            DEPENDS ON: git command          #
    #                                             #
    ###############################################

    btrfs-snp-install-from-repo

    btrfs-sync-install-from-repo

    rsync-helper-scripts-install-from-repo

    discord-install-from-web

    shared-config-nix-check
    shared-config-nix-install

    ssh-check
    ssh-configure

    package-management-helper-scripts-check
    package-management-helper-scripts-install

    images-subvol-check
    images-subvol-create

#     todo write the complete check once you know what to look for in a typical installation...
#     check-emudeck
#
#     if [ $FLAG_emudeck_installed -eq 0 ]; then
#
#         echo "emudeck not detected, pulling installer..."
#
#         from-web-get-emudeck-installer
#
#     fi

    end-step

}

main










